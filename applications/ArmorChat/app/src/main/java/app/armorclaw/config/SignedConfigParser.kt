package app.armorclaw.config

import android.net.Uri
import android.util.Base64
import android.util.Log
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import java.util.concurrent.TimeUnit
import javax.crypto.Mac
import javax.crypto.spec.SecretKeySpec

/**
 * Signed Configuration Parser for ArmorChat
 *
 * Parses signed configuration URLs/QR codes generated by ArmorClaw Bridge.
 * This allows users to scan a QR code after app launch to auto-configure
 * all server URLs (Matrix, Bridge RPC, WebSocket, Push).
 *
 * Security:
 * - Configuration is signed with HMAC-SHA256
 * - Configuration has expiration timestamp
 * - Signature is verified before applying configuration
 * - Trust-on-first-use (TOFU) for bridge identity
 */
object SignedConfigParser {

    private const val TAG = "SignedConfigParser"
    private const val CONFIG_VERSION = 1
    private const val HMAC_ALGORITHM = "HmacSHA256"
    private const val SIGNATURE_PREFIX = "hmac-sha256:"

    private val json = Json {
        ignoreUnknownKeys = true
        isLenient = true
    }

    @Serializable
    data class ConfigPayload(
        val version: Int,
        val token_id: String? = null,
        val matrix_homeserver: String,
        val rpc_url: String,
        val ws_url: String,
        val push_gateway: String,
        val server_name: String,
        val region: String? = null,
        val bridge_public_key: String? = null,
        val expires_at: Long,
        val signature: String
    ) {
        fun isExpired(): Boolean = System.currentTimeMillis() > expires_at * 1000

        fun expiresIn(): Long = maxOf(0L, (expires_at * 1000) - System.currentTimeMillis())

        fun expiresInHuman(): String {
            val seconds = TimeUnit.MILLISECONDS.toSeconds(expiresIn())
            return when {
                seconds < 60 -> "${seconds}s"
                seconds < 3600 -> "${seconds / 60}m"
                seconds < 86400 -> "${seconds / 3600}h"
                else -> "${seconds / 86400}d"
            }
        }

        fun getCanonicalJson(): String {
            val fields = mutableListOf<String>()
            fields.add("\"version\":$version")
            token_id?.let { fields.add("\"token_id\":\"$it\"") }
            fields.add("\"matrix_homeserver\":\"$matrix_homeserver\"")
            fields.add("\"rpc_url\":\"$rpc_url\"")
            fields.add("\"ws_url\":\"$ws_url\"")
            fields.add("\"push_gateway\":\"$push_gateway\"")
            fields.add("\"server_name\":\"$server_name\"")
            region?.let { fields.add("\"region\":\"$it\"") }
            bridge_public_key?.let { fields.add("\"bridge_public_key\":\"$it\"") }
            fields.add("\"expires_at\":$expires_at")
            return "{${fields.joinToString(",")}}"
        }

        fun getBridgeId(): String = bridge_public_key ?: server_name
    }

    sealed class ParseResult {
        data class Success(val config: ConfigPayload) : ParseResult()
        data class Error(val message: String, val code: ErrorCode) : ParseResult()
    }

    enum class ErrorCode {
        INVALID_URL, INVALID_BASE64, INVALID_JSON, EXPIRED_CONFIG,
        VERSION_MISMATCH, MISSING_FIELDS, VERIFICATION_FAILED, INVALID_SIGNATURE_FORMAT
    }

    fun parse(input: String): ParseResult {
        return try {
            when {
                input.startsWith("armorclaw://config") -> parseDeepLink(input)
                input.contains("armorclaw.app/config") -> parseWebUrl(input)
                else -> parseBase64(input)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to parse config", e)
            ParseResult.Error("Parse failed: ${e.message}", ErrorCode.INVALID_URL)
        }
    }

    private fun parseDeepLink(url: String): ParseResult {
        val uri = Uri.parse(url)
        if (uri.scheme != "armorclaw" || uri.host != "config") {
            return ParseResult.Error("Invalid deep link format", ErrorCode.INVALID_URL)
        }
        val data = uri.getQueryParameter("d")
            ?: return ParseResult.Error("Missing config data", ErrorCode.INVALID_URL)
        return parseBase64(data)
    }

    private fun parseWebUrl(url: String): ParseResult {
        val uri = Uri.parse(url)
        val data = uri.getQueryParameter("d")
            ?: return ParseResult.Error("Missing config data", ErrorCode.INVALID_URL)
        return parseBase64(data)
    }

    private fun parseBase64(data: String): ParseResult {
        val jsonBytes = try {
            Base64.decode(data, Base64.URL_SAFE)
        } catch (e: IllegalArgumentException) {
            return ParseResult.Error("Invalid base64 encoding", ErrorCode.INVALID_BASE64)
        }

        val configJson = try {
            json.decodeFromString<ConfigPayload>(String(jsonBytes, Charsets.UTF_8))
        } catch (e: Exception) {
            Log.e(TAG, "JSON parse error", e)
            return ParseResult.Error("Invalid JSON format", ErrorCode.INVALID_JSON)
        }

        if (configJson.version > CONFIG_VERSION) {
            return ParseResult.Error(
                "Config version ${configJson.version} not supported (max: $CONFIG_VERSION)",
                ErrorCode.VERSION_MISMATCH
            )
        }

        if (configJson.matrix_homeserver.isBlank() ||
            configJson.rpc_url.isBlank() ||
            configJson.ws_url.isBlank()) {
            return ParseResult.Error("Missing required fields", ErrorCode.MISSING_FIELDS)
        }

        if (configJson.isExpired()) {
            return ParseResult.Error("Config expired", ErrorCode.EXPIRED_CONFIG)
        }

        return ParseResult.Success(configJson)
    }

    fun verifySignature(config: ConfigPayload, signingKeyHex: String): Boolean {
        return try {
            if (!config.signature.startsWith(SIGNATURE_PREFIX)) {
                Log.e(TAG, "Invalid signature format: missing prefix")
                return false
            }

            val signatureHex = config.signature.removePrefix(SIGNATURE_PREFIX)
            if (signatureHex.isBlank()) {
                Log.e(TAG, "Empty signature")
                return false
            }

            val signingKey = hexToBytes(signingKeyHex)
            val canonicalJson = config.getCanonicalJson()
            val mac = Mac.getInstance(HMAC_ALGORITHM)
            mac.init(SecretKeySpec(signingKey, HMAC_ALGORITHM))
            val computedSignature = mac.doFinal(canonicalJson.toByteArray(Charsets.UTF_8))
            val expectedSignature = hexToBytes(signatureHex)

            constantTimeEquals(computedSignature, expectedSignature)
        } catch (e: Exception) {
            Log.e(TAG, "Signature verification failed", e)
            false
        }
    }

    fun verifyWithTOFU(config: ConfigPayload, trustStore: BridgeTrustStore): TrustResult {
        return try {
            val bridgeId = config.getBridgeId()

            if (!config.signature.startsWith(SIGNATURE_PREFIX)) {
                return TrustResult.Error("Invalid signature format")
            }

            val signatureHex = config.signature.removePrefix(SIGNATURE_PREFIX)
            if (signatureHex.isBlank()) {
                return TrustResult.Error("Empty signature")
            }

            val knownKey = trustStore.getBridgePublicKey(bridgeId)

            if (knownKey != null) {
                if (verifySignature(config, knownKey)) {
                    return TrustResult.Verified(bridgeId, isNew = false)
                } else {
                    return TrustResult.KeyMismatch(bridgeId)
                }
            } else {
                return TrustResult.FirstUse(bridgeId)
            }
        } catch (e: Exception) {
            Log.e(TAG, "TOFU verification failed", e)
            TrustResult.Error(e.message ?: "Verification failed")
        }
    }

    private fun hexToBytes(hex: String): ByteArray {
        return hex.chunked(2).map { it.toInt(16).toByte() }.toByteArray()
    }

    private fun constantTimeEquals(a: ByteArray, b: ByteArray): Boolean {
        if (a.size != b.size) return false
        var result = 0
        for (i in a.indices) {
            result = result or (a[i].toInt() xor b[i].toInt())
        }
        return result == 0
    }

    fun toServerConfig(config: ConfigPayload): ServerConfig {
        return ServerConfig(
            matrixHomeserver = config.matrix_homeserver,
            rpcUrl = config.rpc_url,
            wsUrl = config.ws_url,
            pushGateway = config.push_gateway,
            serverName = config.server_name,
            region = config.region ?: "unknown",
            configSource = ConfigSource.SIGNED_URL,
            expiresAt = config.expires_at * 1000,
            bridgePublicKey = config.bridge_public_key
        )
    }
}

sealed class TrustResult {
    data class Verified(val bridgeId: String, val isNew: Boolean) : TrustResult()
    data class FirstUse(val bridgeId: String) : TrustResult()
    data class KeyMismatch(val bridgeId: String) : TrustResult()
    data class Error(val message: String) : TrustResult()
}

data class ServerConfig(
    val matrixHomeserver: String,
    val rpcUrl: String,
    val wsUrl: String,
    val pushGateway: String,
    val serverName: String,
    val region: String = "unknown",
    val configSource: ConfigSource = ConfigSource.DEFAULT,
    val expiresAt: Long = Long.MAX_VALUE,
    val bridgePublicKey: String? = null
) {
    val isDebug: Boolean
        get() = matrixHomeserver.contains("10.") ||
                matrixHomeserver.contains("192.168.") ||
                matrixHomeserver.contains("localhost") ||
                matrixHomeserver.contains("10.0.2.2")

    val isDevelopment: Boolean
        get() = isDebug || matrixHomeserver.contains(":80") || rpcUrl.contains(":8080")

    val isProduction: Boolean
        get() = !isDevelopment && matrixHomeserver.startsWith("https://")

    fun isExpired(): Boolean = System.currentTimeMillis() > expiresAt

    fun validateSecurity(): SecurityValidation {
        val issues = mutableListOf<String>()

        if (!isDebug && !matrixHomeserver.startsWith("https://")) {
            issues.add("HTTPS required for production servers")
        }
        if (!isDebug && !rpcUrl.startsWith("https://") && !rpcUrl.startsWith("unix://")) {
            issues.add("HTTPS required for RPC URL")
        }
        if (!isDebug && !wsUrl.startsWith("wss://")) {
            issues.add("WSS required for WebSocket URL")
        }
        if (matrixHomeserver.startsWith("http://") && !isDebug) {
            issues.add("HTTP transmits credentials in plaintext")
        }

        return if (issues.isEmpty()) SecurityValidation.Valid else SecurityValidation.Invalid(issues)
    }
}

sealed class SecurityValidation {
    object Valid : SecurityValidation()
    data class Invalid(val issues: List<String>) : SecurityValidation()
}

enum class ConfigSource {
    DEFAULT, SIGNED_URL, MANUAL, CACHED
}
