package com.armorclaw.armorterminal.config

import android.net.Uri
import android.util.Base64
import android.util.Log
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import java.security.MessageDigest
import java.util.concurrent.TimeUnit
import javax.crypto.Mac
import javax.crypto.spec.SecretKeySpec

/**
 * Signed Configuration Parser for ArmorTerminal
 *
 * Parses signed configuration URLs/QR codes generated by ArmorClaw Bridge.
 * This allows users to scan a QR code after app launch to auto-configure
 * all server URLs (Matrix, Bridge RPC, WebSocket, Push).
 *
 * Security:
 * - Configuration is signed with HMAC-SHA256
 * - Configuration has expiration timestamp
 * - Signature is verified before applying configuration
 * - Trust-on-first-use (TOFU) for bridge identity
 *
 * Usage:
 * 1. Bridge generates signed config URL: armorclaw://config?d=base64(json)
 * 2. User scans QR code or taps deep link
 * 3. App parses and verifies config
 * 4. App applies config to ServerConfig
 */
object SignedConfigParser {

    private const val TAG = "SignedConfigParser"
    private const val CONFIG_VERSION = 1
    private const val HMAC_ALGORITHM = "HmacSHA256"
    private const val SIGNATURE_PREFIX = "hmac-sha256:"

    private val json = Json {
        ignoreUnknownKeys = true
        isLenient = true
    }

    /**
     * Parsed configuration from signed URL
     */
    @Serializable
    data class ConfigPayload(
        val version: Int,
        val token_id: String? = null,
        val matrix_homeserver: String,
        val rpc_url: String,
        val ws_url: String,
        val push_gateway: String,
        val server_name: String,
        val region: String? = null,
        val bridge_public_key: String? = null,
        val expires_at: Long,
        val signature: String
    ) {
        fun isExpired(): Boolean {
            return System.currentTimeMillis() > expires_at * 1000
        }

        fun expiresIn(): Long {
            return maxOf(0L, (expires_at * 1000) - System.currentTimeMillis())
        }

        fun expiresInHuman(): String {
            val seconds = TimeUnit.MILLISECONDS.toSeconds(expiresIn())
            return when {
                seconds < 60 -> "${seconds}s"
                seconds < 3600 -> "${seconds / 60}m"
                seconds < 86400 -> "${seconds / 3600}h"
                else -> "${seconds / 86400}d"
            }
        }

        /**
         * Get canonical JSON for signature verification (without signature field)
         */
        fun getCanonicalJson(): String {
            val fields = mutableListOf<String>()
            fields.add("\"version\":$version")
            token_id?.let { fields.add("\"token_id\":\"$it\"") }
            fields.add("\"matrix_homeserver\":\"$matrix_homeserver\"")
            fields.add("\"rpc_url\":\"$rpc_url\"")
            fields.add("\"ws_url\":\"$ws_url\"")
            fields.add("\"push_gateway\":\"$push_gateway\"")
            fields.add("\"server_name\":\"$server_name\"")
            region?.let { fields.add("\"region\":\"$it\"") }
            bridge_public_key?.let { fields.add("\"bridge_public_key\":\"$it\"") }
            fields.add("\"expires_at\":$expires_at")
            return "{${fields.joinToString(",")}}"
        }

        /**
         * Get bridge identifier for TOFU
         */
        fun getBridgeId(): String {
            return bridge_public_key ?: server_name
        }
    }

    /**
     * Result of parsing a configuration URL
     */
    sealed class ParseResult {
        data class Success(val config: ConfigPayload) : ParseResult()
        data class Error(val message: String, val code: ErrorCode) : ParseResult()
    }

    enum class ErrorCode {
        INVALID_URL,
        INVALID_BASE64,
        INVALID_JSON,
        EXPIRED_CONFIG,
        VERSION_MISMATCH,
        MISSING_FIELDS,
        VERIFICATION_FAILED,
        INVALID_SIGNATURE_FORMAT
    }

    /**
     * Parse a configuration URL/QR code
     *
     * @param input Either a deep link (armorclaw://config?d=...) or base64 encoded config
     * @return ParseResult with config or error
     */
    fun parse(input: String): ParseResult {
        return try {
            when {
                // Deep link format: armorclaw://config?d=base64
                input.startsWith("armorclaw://config") -> parseDeepLink(input)

                // Web URL format: https://armorclaw.app/config?d=base64
                input.contains("armorclaw.app/config") -> parseWebUrl(input)

                // Assume raw base64
                else -> parseBase64(input)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to parse config", e)
            ParseResult.Error("Parse failed: ${e.message}", ErrorCode.INVALID_URL)
        }
    }

    /**
     * Parse deep link format: armorclaw://config?d=base64
     */
    private fun parseDeepLink(url: String): ParseResult {
        val uri = Uri.parse(url)

        if (uri.scheme != "armorclaw" || uri.host != "config") {
            return ParseResult.Error("Invalid deep link format", ErrorCode.INVALID_URL)
        }

        val data = uri.getQueryParameter("d")
            ?: return ParseResult.Error("Missing config data", ErrorCode.INVALID_URL)

        return parseBase64(data)
    }

    /**
     * Parse web URL format: https://armorclaw.app/config?d=base64
     */
    private fun parseWebUrl(url: String): ParseResult {
        val uri = Uri.parse(url)
        val data = uri.getQueryParameter("d")
            ?: return ParseResult.Error("Missing config data", ErrorCode.INVALID_URL)

        return parseBase64(data)
    }

    /**
     * Parse base64 encoded JSON config
     */
    private fun parseBase64(data: String): ParseResult {
        // Decode base64
        val jsonBytes = try {
            Base64.decode(data, Base64.URL_SAFE)
        } catch (e: IllegalArgumentException) {
            return ParseResult.Error("Invalid base64 encoding", ErrorCode.INVALID_BASE64)
        }

        // Parse JSON
        val configJson = try {
            json.decodeFromString<ConfigPayload>(String(jsonBytes, Charsets.UTF_8))
        } catch (e: Exception) {
            Log.e(TAG, "JSON parse error", e)
            return ParseResult.Error("Invalid JSON format", ErrorCode.INVALID_JSON)
        }

        // Validate version
        if (configJson.version > CONFIG_VERSION) {
            return ParseResult.Error(
                "Config version ${configJson.version} not supported (max: $CONFIG_VERSION)",
                ErrorCode.VERSION_MISMATCH
            )
        }

        // Validate required fields
        if (configJson.matrix_homeserver.isBlank() ||
            configJson.rpc_url.isBlank() ||
            configJson.ws_url.isBlank()) {
            return ParseResult.Error("Missing required fields", ErrorCode.MISSING_FIELDS)
        }

        // Check expiration
        if (configJson.isExpired()) {
            return ParseResult.Error("Config expired", ErrorCode.EXPIRED_CONFIG)
        }

        return ParseResult.Success(configJson)
    }

    /**
     * Verify config signature using HMAC-SHA256
     *
     * @param config The config to verify
     * @param signingKeyHex The hex-encoded signing key from the bridge
     * @return true if signature is valid
     */
    fun verifySignature(config: ConfigPayload, signingKeyHex: String): Boolean {
        return try {
            // Validate signature format
            if (!config.signature.startsWith(SIGNATURE_PREFIX)) {
                Log.e(TAG, "Invalid signature format: missing prefix")
                return false
            }

            // Extract signature hex
            val signatureHex = config.signature.removePrefix(SIGNATURE_PREFIX)
            if (signatureHex.isBlank()) {
                Log.e(TAG, "Empty signature")
                return false
            }

            // Convert signing key from hex
            val signingKey = hexToBytes(signingKeyHex)

            // Compute HMAC-SHA256 of canonical JSON
            val canonicalJson = config.getCanonicalJson()
            val mac = Mac.getInstance(HMAC_ALGORITHM)
            mac.init(SecretKeySpec(signingKey, HMAC_ALGORITHM))
            val computedSignature = mac.doFinal(canonicalJson.toByteArray(Charsets.UTF_8))

            // Compare with provided signature (constant-time comparison)
            val expectedSignature = hexToBytes(signatureHex)
            return constantTimeEquals(computedSignature, expectedSignature)
        } catch (e: Exception) {
            Log.e(TAG, "Signature verification failed", e)
            false
        }
    }

    /**
     * Verify config using first-use trust (TOFU)
     *
     * For first-time setup, we trust the config if it comes from armorclaw:// deep link
     * and has a valid signature format. The bridge identity is stored for future verification.
     *
     * @param config The config to verify
     * @param trustStore The trust store to check/update
     * @return TrustResult indicating verification status
     */
    fun verifyWithTOFU(config: ConfigPayload, trustStore: BridgeTrustStore): TrustResult {
        return try {
            val bridgeId = config.getBridgeId()

            // Check if signature format is valid
            if (!config.signature.startsWith(SIGNATURE_PREFIX)) {
                return TrustResult.Error("Invalid signature format")
            }

            val signatureHex = config.signature.removePrefix(SIGNATURE_PREFIX)
            if (signatureHex.isBlank()) {
                return TrustResult.Error("Empty signature")
            }

            // Check if we know this bridge
            val knownKey = trustStore.getBridgePublicKey(bridgeId)

            if (knownKey != null) {
                // Known bridge - verify signature with stored key
                if (verifySignature(config, knownKey)) {
                    return TrustResult.Verified(bridgeId, isNew = false)
                } else {
                    return TrustResult.KeyMismatch(bridgeId)
                }
            } else {
                // New bridge - first use trust
                // We trust the config but note it's a new connection
                return TrustResult.FirstUse(bridgeId)
            }
        } catch (e: Exception) {
            Log.e(TAG, "TOFU verification failed", e)
            TrustResult.Error(e.message ?: "Verification failed")
        }
    }

    /**
     * Convert hex string to byte array
     */
    private fun hexToBytes(hex: String): ByteArray {
        return hex.chunked(2)
            .map { it.toInt(16).toByte() }
            .toByteArray()
    }

    /**
     * Constant-time byte array comparison to prevent timing attacks
     */
    private fun constantTimeEquals(a: ByteArray, b: ByteArray): Boolean {
        if (a.size != b.size) return false
        var result = 0
        for (i in a.indices) {
            result = result or (a[i].toInt() xor b[i].toInt())
        }
        return result == 0
    }

    /**
     * Convert ConfigPayload to ServerConfig
     */
    fun toServerConfig(config: ConfigPayload): ServerConfig {
        return ServerConfig(
            matrixHomeserver = config.matrix_homeserver,
            rpcUrl = config.rpc_url,
            wsUrl = config.ws_url,
            pushGateway = config.push_gateway,
            serverName = config.server_name,
            region = config.region ?: "unknown",
            configSource = ConfigSource.SIGNED_URL,
            expiresAt = config.expires_at * 1000,
            bridgePublicKey = config.bridge_public_key
        )
    }
}

/**
 * Result of TOFU verification
 */
sealed class TrustResult {
    data class Verified(val bridgeId: String, val isNew: Boolean) : TrustResult()
    data class FirstUse(val bridgeId: String) : TrustResult()
    data class KeyMismatch(val bridgeId: String) : TrustResult()
    data class Error(val message: String) : TrustResult()
}

/**
 * Server configuration data
 */
data class ServerConfig(
    val matrixHomeserver: String,
    val rpcUrl: String,
    val wsUrl: String,
    val pushGateway: String,
    val serverName: String,
    val region: String = "unknown",
    val configSource: ConfigSource = ConfigSource.DEFAULT,
    val expiresAt: Long = Long.MAX_VALUE,
    val bridgePublicKey: String? = null
) {
    val isDebug: Boolean
        get() = matrixHomeserver.contains("10.") ||
                matrixHomeserver.contains("192.168.") ||
                matrixHomeserver.contains("localhost") ||
                matrixHomeserver.contains("10.0.2.2")

    val isDevelopment: Boolean
        get() = isDebug || matrixHomeserver.contains(":80") || rpcUrl.contains(":8080")

    val isProduction: Boolean
        get() = !isDevelopment && matrixHomeserver.startsWith("https://")

    val serverDisplayName: String
        get() = if (serverName.isNotBlank()) serverName else extractDomain(matrixHomeserver)

    fun isExpired(): Boolean = System.currentTimeMillis() > expiresAt

    /**
     * Validate security requirements for production
     */
    fun validateSecurity(): SecurityValidation {
        val issues = mutableListOf<String>()

        // Require HTTPS for production (non-debug) servers
        if (!isDebug && !matrixHomeserver.startsWith("https://")) {
            issues.add("HTTPS required for production servers")
        }
        if (!isDebug && !rpcUrl.startsWith("https://") && !rpcUrl.startsWith("unix://")) {
            issues.add("HTTPS required for RPC URL")
        }
        if (!isDebug && !wsUrl.startsWith("wss://")) {
            issues.add("WSS required for WebSocket URL")
        }

        // Check for plaintext credentials risk
        if (matrixHomeserver.startsWith("http://") && !isDebug) {
            issues.add("HTTP transmits credentials in plaintext")
        }

        return if (issues.isEmpty()) {
            SecurityValidation.Valid
        } else {
            SecurityValidation.Invalid(issues)
        }
    }

    private fun extractDomain(url: String): String {
        return url
            .removePrefix("https://")
            .removePrefix("http://")
            .substringBefore(":")
            .substringBefore("/")
    }
}

/**
 * Security validation result
 */
sealed class SecurityValidation {
    object Valid : SecurityValidation()
    data class Invalid(val issues: List<String>) : SecurityValidation()
}

/**
 * Source of configuration
 */
enum class ConfigSource {
    DEFAULT,      // BuildConfig defaults
    SIGNED_URL,   // Scanned QR / deep link
    MANUAL,       // User entered manually
    CACHED        // Previously saved config
}

/**
 * Config change event for notifying the app
 */
data class ConfigChangeEvent(
    val oldConfig: ServerConfig?,
    val newConfig: ServerConfig,
    val source: ConfigSource
)
